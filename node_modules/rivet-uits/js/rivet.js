/*! Rivet - @version v0.5.0 */

/**
 * Element.closest() polyfill
 * https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill
 */
if (!Element.prototype.closest) {
    if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    }
    Element.prototype.closest = function (s) {
        var el = this;
        var ancestor = this;
        if (!document.documentElement.contains(el)) return null;
        do {
            if (ancestor.matches(s)) return ancestor;
            ancestor = ancestor.parentElement;
        } while (ancestor !== null);
        return null;
    };
}

var Alert = (function() {
    var init = function() {
        _bindUiActions();
    }

    var _bindUiActions = function() {
        document.addEventListener('click', function(e) {
            _handleClick(e);
        });
    }

    var _handleClick = function(event) {
        var dismissButton = event.target.closest('.rvt-alert__dismiss');

        // If the target wasn't the dismiss button bail.
        if (!dismissButton) return;

        // Get the parent node of the dsimiss button i.e. the alert container
        var alertThatWasClicked = dismissButton.parentNode;

        dismissAlert(alertThatWasClicked);
    }

    var dismissAlert = function(alert) {
        alert.parentNode.removeChild(alert);
    }

    // Expose public methods
    return {
        init: init,
        dismiss: dismissAlert
    }
})();

var Drawer = (function() {
    var drawerTrigger = null;
    var drawerSubnavTriggers = null;
    var drawerId = null;
    var drawerEl = null;
    var drawerBottomClose = null;

    var init = function(context) {
        if (context === undefined) {
            context = document;
        }

        drawerTrigger = context.querySelector('[data-drawer-toggle]');
        drawerSubnavTriggers = context.querySelectorAll('[data-subnav-toggle]');
        drawerId = drawerTrigger ? drawerTrigger.getAttribute('data-drawer-toggle') : null;
        drawerEl = context.querySelector('#' + drawerId);
        drawerBottomClose = drawerEl ? drawerEl.querySelector('.rvt-drawer__bottom-close') : null;

        // Check to make sure the drawer is present in the DOM
        if(drawerTrigger) {
            _bindUiActions();
        }
    }

    var toggleBtnState = function (buttonEl) {
        var isExpanded = buttonEl.getAttribute('aria-expanded') === 'true' || false;
        buttonEl.setAttribute('aria-expanded', !isExpanded);
    }

    var toggleHiddenState = function (itemToToggle) {
        var itemState = itemToToggle.getAttribute('aria-hidden') === 'true' || false;
        itemToToggle.setAttribute('aria-hidden', !itemState);
    }

    var resetDrawer = function (drawerEl, drawerTrigger) {
        drawerEl.setAttribute('aria-hidden', 'true');
        drawerTrigger.setAttribute('aria-expanded', 'false');
        drawerTrigger.classList.remove('is-open');
    }

    var toggle = function(trigger, target, event) {
        if(event) {
            event.preventDefault();
            event.stopPropagation();
        }

        // Toggle aria-expanded state of the button
        toggleBtnState(trigger);

        // Toggle the aria-hidden state of the drawer
        toggleHiddenState(target);

        // Toggle button open class
        trigger.classList.toggle('is-open');
    }

    var _bindUiActions = function() {
        drawerTrigger.addEventListener('click', function(e) {
            toggle(this, drawerEl, e)
        });

        for(var i = 0; i < drawerSubnavTriggers.length; i++) {
            drawerSubnavTriggers[i].addEventListener('click', function(e) {
                toggle(this, document.querySelector('#' + this.getAttribute('data-subnav-toggle')), e)
            });
        }

        // Make sure the extra close button is present in the DOM
        if (drawerBottomClose) {
            drawerBottomClose.addEventListener('click', function (e) {
                toggle(drawerTrigger, drawerEl, e);
            });
        }

        // Close the drawer if the user presses the ESC key
        document.addEventListener('keyup', function(e) {
            if(e.keyCode == 27 && drawerEl.getAttribute('aria-hidden') != 'true') {
                toggle(drawerTrigger, drawerEl, e);
            }
        });

        document.addEventListener('click', function(e) {
            if(e.target != drawerEl && !drawerEl.contains(e.target)) {
                resetDrawer(drawerEl, drawerTrigger);
            }
        });
    }

    return {
        init: init,
        toggle: toggle
    }
})();


/**
 * Same here. This is a start, but needs more work.
 */

var Dropdown = (function() {
    // For easy reference
    var keys = {
        up: 38,
        down: 40,
        tab: 9,
        escape: 27
    };

    var expanded = 'aria-expanded';
    var hidden = 'aria-hidden';
    var allFocusableEls = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex="0"]';

    /**
     * The init checks to make sure that there are any dropdown buttons
     * on the page then kicks off all the event listeners.
     */
    var init = function(context) {
        if (context === undefined) {
            context = document;
        }    

        /**
         * This is the initial set up that caches selectors and properties
         * from the DOM.
         */
        var btnToggles = context.querySelectorAll('[data-dropdown-toggle]');

        // Check to make sure there are doropdown menus in the DOM.
        if (btnToggles.length > 0) {
            /**
             * Main toggle action
             */
            for (var i = 0; i < btnToggles.length; i++) {
                btnToggles[i].addEventListener('click', function (event) {
                    var dropdown = findDropdown(this);

                    toggle(dropdown.toggle, dropdown.menu, event);
                });

                /**
                 * The first time a user is focused on a dropdown toggle
                 * and presses the down key we want the dropdown to open,
                 * but not focus the first element in the menu.
                 */
                btnToggles[i].addEventListener('keyup', function(event) {
                    var dropdown = findDropdown(this);

                    if(event.keyCode == keys.down) {
                        event.preventDefault();
                        toggle(dropdown.toggle, dropdown.menu, event);
                    }
                });

                /**
                 * Then an additional press of the down key should focus the
                 * first focusable element in the menu.
                 */
                btnToggles[i].addEventListener('keydown', function (event) {
                    var dropdown = findDropdown(this);

                    if (event.keyCode == keys.down) {
                        event.preventDefault();
                        dropdown.firstFocusable.focus();
                    }

                    if (event.keyCode == keys.escape && dropdown.menu.getAttribute('aria-hidden') == 'false') {
                        toggle(dropdown.toggle, dropdown.menu, event);
                    }
                });
            }

            btnToggles = Array.prototype.slice.call(btnToggles);
            btnToggles.forEach(function(btn) {
                var menu = findDropdown(btn);
                /**
                 * Stop click on dropdown menus from bubbling up
                 */
                menu.menu.addEventListener('click', function (event) {
                    event.clickWithinMenu = true;
                });

                menu.menu.addEventListener('keydown', function (event) {
                    // Handle all the different keyboard interactions.
                    _handleKeydown(menu, event);
                });
            });

            /**
             * Listen for clicks outside of the dropdown button and close all
             * opened dropdown menus.
             */
            document.addEventListener('click', function (event) {
                if (!event.clickWithinMenu) {
                    closeAllMenus(undefined);
                }
            });
        }
    }

    /**
     *
     * @param {Object} menu
     * An object containing all the refernces we need to work with an
     * instance of a dropdown menu. See findDropdown() for more info.
     * @param {Object} event
     * The event object
     */
    var _handleKeydown = function (menu, event) {
        switch (event.keyCode) {
            case keys.escape:
                toggle(menu.toggle, menu.menu, event);

                // Retrun focus to the current toggle button
                menu.toggle.focus();
                break;
            case keys.down:
                event.preventDefault();
                var currentIndex;

                for (var i = 0; i < menu.focusables.length; i++) {
                    if (event.target == menu.focusables[i]) {
                        currentIndex = i;
                    }
                }
                // Store a reference to the next button or link
                var next = menu.focusables[currentIndex + 1];

                /**
                 * If it's the last button or link return focus to
                 * the first focusable element.
                 */
                if (!next) {
                    menu.firstFocusable.focus();
                    return;
                }

                // Otherwise focus the next element.
                next.focus();
                break;
            case keys.up:
                event.preventDefault();
                var currentIndex;

                for (var i = 0; i < menu.focusables.length; i++) {
                    if (event.target == menu.focusables[i]) {
                        currentIndex = i;
                    }
                }

                var previous = menu.focusables[currentIndex - 1];

                if(!previous) {
                    menu.lastFocusable.focus();
                    return;
                }

                previous.focus();
                break;
            case keys.tab:
                if (document.activeElement == menu.lastFocusable && !event.shiftKey) {
                    /**
                     * NOTE:
                     * Don't pass the event to the toggle function
                     * here because we don't want to prevent the
                     * default behavior of the tab key moving focus
                     * to whatever is the next focusable thing
                     * in the DOM. QUESTION: Do we need to preventDefault on this
                     * toggle function if we are encouraging folks to use
                     * HTML button elements (not links) toggle stuff?
                     */
                    toggle(menu.toggle, menu.menu, null);
                }
            default:
                break;
        }
    }

    /**
     *
     * @param {HTMLElement} el
     * Accepts dropdown toggle and returns an object containing
     * references to the menu it controls, and id, the toggle itself,
     * all focusable elements inside the menu, and the first and
     * last focusable elements.
     *
     */
    var findDropdown = function (el) {
        var menu = {};

        menu.toggle = el;
        menu.id = el.getAttribute('data-dropdown-toggle');
        menu.menu = document.querySelector('#' + menu.id);

        // Find all focusable elements in the dropdown
        menu.focusables = menu.menu.querySelectorAll(allFocusableEls);

        // Find first focusable element
        menu.firstFocusable = menu.focusables[0];

        // Find last focusable element
        menu.lastFocusable = menu.focusables[menu.focusables.length - 1];

        return menu;
    }

    var toggle = function(trigger, target, event) {
        if(event) {
            event.preventDefault();
            event.stopPropagation();
            event.clickWithinMenu = true
        }

        // Close all of the menus except for this one
        closeAllMenus(target);
        // Toggle the aria-expanded state of the button that was clicked.
        toggleBtnState(trigger);
        // Toggle the aria-hidden state of the corresponding dropdown.
        toggleMenuState(target);
    }

    // Toggles the aria-expanded state of the target button
    var toggleBtnState = function(buttonEl) {
        var isExpanded = buttonEl.getAttribute(expanded) === 'true' || false;
        buttonEl.setAttribute(expanded, !isExpanded);
    }

    // Toggles the aria-hidden state of the dropdown menu
    var toggleMenuState = function(dropdownMenuEl) {
        var menuState = dropdownMenuEl.getAttribute(hidden) === 'true' || false;
        dropdownMenuEl.setAttribute(hidden, !menuState);
    }

    /**
     *
     * @param {String} id
     * The value of the dropdown toggle data-dropdown-toggle attribute and
     * matching id of the dropdown men it controls.
     *
     * This is a helper function that we expose as part of the public API.
     */

    var toggleById = function(id) {
        var toggleButton = document.querySelector('[data-dropdown-toggle="' + id + '"]');
        var toggleMenu = document.getElementById(id);

        toggle(toggleButton, toggleMenu);
    }

    /**
     * Closes any open dropdown menus and sets the corresponding trigger's
     * aria-exapnded state back to "false"
     */

    var closeAllMenus = function(menuToLeaveOpen) {
        var menus = document.querySelectorAll('.rvt-dropdown__menu, .dropdown__menu');
        for(var i = 0; i < menus.length; i ++) {
            if(menuToLeaveOpen != menus[i]) {
                menus[i].setAttribute(hidden, 'true');
                var triggerElData = menus[i].getAttribute('id');
                var triggerEl = document.querySelector('[data-dropdown-toggle="' + triggerElData + '"]');
                triggerEl.setAttribute(expanded, 'false');
            }
        }
    }

    /**
     * This return statement exposes the functions that need to be availble
     * to initialize the everything and provide programatic access to the
     * closeAllMenus function if needed.
     */

    return {
        init: init,
        closeAll: closeAllMenus,
        toggle: toggleById
    }
})();


/**
 * A lot of this is largely based on the great work in this article:
 * https://bitsofco.de/accessible-modal-modal/
 */

var Modal = (function () {
    /**
     * Set up
     */

    
    var modals = null;
    var modalTriggers = null;
    var allFocusableEls = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex="0"]';

    /**
     * We need these to pass around values that multiple
     * 'Modal' methods will need access to.
     */

    var isDialog;
    var focusedElBeforeOpen;
    var focusableEls;
    var firstFocusableEl;
    var lastFocusableEl;

    /**
     * Kick everything off here.
     */
    var init = function (context) {
        if (context === undefined) {
            context = document;
        }

        /**
         * Adding both prefixed ".rvt-" and old ".modal"  versions of the
         * selectors here. Let's eventually look at deprecating the
         * old un-prefixed version.
        */
        modals = document.querySelectorAll('.rvt-modal, .modal');
        modalTriggers = document.querySelectorAll('[data-modal-trigger]');
        // Make modalTriggers an array
        modalTriggers = Array.prototype.slice.call(modalTriggers);

        // Check to see if any modals exist on the page.
        if (modals.length != 0 && modalTriggers.length != 0) {
            _bindUiActions();
        }
    }

    var _bindUiActions = function () {
        modalTriggers.forEach(function (el) {
            el.addEventListener('click', function () {
                // Set up
                var modalID = el.getAttribute('data-modal-trigger');
                var modalEl = document.querySelector('#' + modalID);

                // Open the modal
                openModal(modalEl);
            });
        });
    }

    /**
     * @param {object} currentModal - The current HTML modal element to open.
     */
    var openModal = function (currentModal) {
        // Is the modal a modal dialog i.e. clicking background doesn't close?
        isDialog = currentModal.getAttribute('data-modal-dialog');

        // Store a reference to the inner modal container
        var modalElInner = currentModal.querySelector('.rvt-modal__inner, .modal__inner');

        /**
         * Get all the close triggers for the current modal. This includes
         * the default close (x) button, but could be other triggers
         * like a cancel button, etc.
         */
        var modalCloseButtons = currentModal.querySelectorAll('[data-modal-close]');

        // Convert nodelist to an array
        modalCloseButtons = Array.prototype.slice.call(modalCloseButtons);

        modalCloseButtons.forEach(function (el) {
            el.addEventListener('click', function () {
                closeModal(currentModal);
            });
        });

        // Get anything that's focusable
        focusableEls = currentModal.querySelectorAll(allFocusableEls);

        // Make focusableEls an Arry so we can do Array stuff with it.
        focusableEls = Array.prototype.slice.call(focusableEls);

        /**
         * Find the first and last focusable element in the array and
         * store them in variable where other methods can find them.
         */
        firstFocusableEl = focusableEls[0];
        lastFocusableEl = focusableEls[focusableEls.length - 1];

        /**
         * Add a class to the body that we use as a hook to allow
         * the modal to scroll.
         */
        if (document.body) {
            document.body.classList.add('rvt-modal-open');
        }

        /**
         * Store a reference to modal trigger that was clicked so that
         * we can return focus to it later.
         */
        focusedElBeforeOpen = document.activeElement;

        // Remove aria-hidden attr to show the modal.
        currentModal.removeAttribute('aria-hidden');

        /**
         * If the modal isn't a modal dialog allow user to click
         * the background to close.
         */
        if (!isDialog) {
            // Hide the modal if use clicks on background.
            currentModal.addEventListener('click', function () {
                closeModal(this);
            });
        }

        // Stops clicking on the actual modal stuff from bubbling up.
        modalElInner.addEventListener('click', function (e) {
            e.stopPropagation();
        });

        // Listen for tab or escape keys and handle events.
        currentModal.addEventListener('keydown', function (e) {
            _handleKeyDown(currentModal, e);
        });

        // Add focus to the modal that just opened.
        currentModal.focus();
    }

    /**
     * @param {object} modalToHandle - The current HTML modal element to open.
     * @param {object} e - The event object
     */
    var _handleKeyDown = function (modalToHandle, e) {
        var KEY_TAB = 9;
        var KEY_ESC = 27;

        function handleBackwardTab() {
            if (document.activeElement === firstFocusableEl) {
                e.preventDefault();
                lastFocusableEl.focus();
            }
        }

        function handleForwardTab() {
            if (document.activeElement === lastFocusableEl) {
                e.preventDefault();
                firstFocusableEl.focus();
            }
        }

        switch (e.keyCode) {
            case KEY_TAB:
                if (e.shiftKey) {
                    handleBackwardTab();
                } else {
                    handleForwardTab();
                }
                break;

            case KEY_ESC:
                if (!isDialog) {
                    closeModal(modalToHandle);
                }
                break;

            default:
                break;
        }
    }

    /**
     * @param {object} modalToClose - The HTML modal element to close.
     */
    var closeModal = function (modalToClose) {
        if (document.body) {
            document.body.removeAttribute('class');
        }

        modalToClose.setAttribute('aria-hidden', 'true');

        /**
         * Return focus to the modal trigger that originally
         * opened the modal.
         */
        if (focusedElBeforeOpen) {
            focusedElBeforeOpen.focus();
        }
    }

    return {
        init: init,
        open: openModal,
        close: closeModal
    }
})();


var Tabs = (function() {

    /**
     * Set up locally-scoped variables
     * Aria requirements https://www.w3.org/TR/wai-aria-practices/#tabpanel
     */

    /**
     * Get all the tab sets on the page
     */
    var tabSets = null;

    var tablist = []
    var tabs = []
    var panels = []

    function generateArrays () {
        for (var tabsetIndex = 0; tabsetIndex < tabSets.length; tabsetIndex++) {
            tablist[tabsetIndex] = tabSets[tabsetIndex].querySelectorAll('[role="tablist"]')[0]
            tabs[tabsetIndex] = tabSets[tabsetIndex].querySelectorAll('[role="tab"]')
            panels[tabsetIndex] = tabSets[tabsetIndex].querySelectorAll('[role="tabpanel"]')
        }
    }

    // For easy reference
    var keys = {
        end: 35,
        home: 36,
        left: 37,
        up: 38,
        right: 39,
        down: 40,
        enter: 13,
        space: 32
    }

    // Add or subtract depending on key pressed
    var direction = {
        37: -1,
        38: -1,
        39: 1,
        40: 1
    }

    var init = function(context) {
        if (context === undefined) {
            context = document;
        }

        tabSets = context.querySelectorAll('.rvt-tabs')
        generateArrays();

        // Check to make sure there are any tab sets in the DOM.
        if(tabSets.length != 0) {

            // Loop through the tab sets and initialize each one
            for (var tabsetIndex = 0; tabsetIndex < tabSets.length; tabsetIndex++) {
                _bindUiActions(tabs[tabsetIndex], tabsetIndex);
            }
        }
    }

    /**
     * @param {object} els - HTML elements to bind the actions to.
     */
    var _bindUiActions = function(tabs, tabsetIndex) {

        for (var i = 0; i < tabs.length; i++) {

            tabs[i].addEventListener('click', function(event) { clickEventListener(event, tabsetIndex) });
            tabs[i].addEventListener('keydown', function(event) { keydownEventListener(event, tabsetIndex) });
            tabs[i].addEventListener('keyup', function(event) { keyupEventListener(event, tabsetIndex) });

            // Build an array with all tabs (<button>s) in it
            tabs[i].index = i;
            tabs[i].tabsetIndex = tabsetIndex
        }
    }

    // When a tab is clicked, activateTab is fired to activate it
    function clickEventListener (event, tabsetIndex) {
        var tab = event.target;
        activateTab(tab, tabsetIndex, false);
    }

    // Handle keydown on tabs
    function keydownEventListener (event, tabsetIndex) {
        var key = event.keyCode;

        switch (key) {
            case keys.end:
                event.preventDefault();
                // Activate last tab
                focusLastTab(tabsetIndex);
                break;
            case keys.home:
                event.preventDefault();
                // Activate first tab
                focusFirstTab(tabsetIndex);
                break;

            // Up and down are in keydown
            // because we need to prevent page scroll >:)
            case keys.up:
            case keys.down:
                determineOrientation(event, tabsetIndex);
                break;
        }
    }

    // Handle keyup on tabs
    function keyupEventListener (event, tabsetIndex) {
        var key = event.keyCode;

        switch (key) {
            case keys.left:
            case keys.right:
                determineOrientation(event, tabsetIndex);
                break;
            case keys.enter:
            case keys.space:
                activateTab(event.target, tabsetIndex);
                break;
        }
    }

    // When a tablists aria-orientation is set to vertical,
    // only up and down arrow should function.
    // In all other cases only left and right arrow function.
    function determineOrientation (event, tabsetIndex) {
        var key = event.keyCode;
        var vertical = tablist[tabsetIndex].getAttribute('aria-orientation') == 'vertical';
        var proceed = false;

        if (vertical) {
            if (key === keys.up || key === keys.down) {
                event.preventDefault();
                proceed = true;
            }
        }
        else {
            if (key === keys.left || key === keys.right) {
                proceed = true;
            }
        }

        if (proceed) {
            switchTabOnArrowPress(event, tabsetIndex);
        }
    }


    // Either focus the next, previous, first, or last tab
    // depending on key pressed
    function switchTabOnArrowPress (event, tabsetIndex) {
        var pressed = event.keyCode;

        if (direction[pressed]) {
            var target = event.target;
            if (target.index !== undefined) {
                if (tabs[tabsetIndex][target.index + direction[pressed]]) {
                    tabs[tabsetIndex][target.index + direction[pressed]].focus();
                }
                else if (pressed === keys.left || pressed === keys.up) {
                    focusLastTab(tabsetIndex);
                }
                else if (pressed === keys.right || pressed == keys.down) {
                    focusFirstTab(tabsetIndex);
                }
            }
        }
    }

    // Activates any given tab panel
    function activateTab (tab, tabsetIndex, setFocus) {

        setFocus = setFocus || true;

        // Deactivate all other tabs in tabset
        deactivateTabs(tabsetIndex);

        // Remove tabindex attribute
        tab.removeAttribute('tabindex');

        // Set the tab as selected
        tab.setAttribute('aria-selected', 'true');

        // Get the value of aria-controls (which is an ID)
        var controls = tab.getAttribute('aria-controls');

        // Remove hidden attribute from tab panel to make it visible
        document.getElementById(controls).removeAttribute('hidden');

        // Set focus when required
        if (setFocus) {
            tab.focus();
        }
    }

    // Deactivate all tabs and tab panels
    function deactivateTabs (tabsetIndex) {

        for (var t = 0; t < tabs[tabsetIndex].length; t++) {
            tabs[tabsetIndex][t].setAttribute('tabindex', '-1');
            tabs[tabsetIndex][t].setAttribute('aria-selected', 'false');
        }

        for (var p = 0; p < panels[tabsetIndex].length; p++) {
            panels[tabsetIndex][p].setAttribute('hidden', 'hidden');
        }
    }

    // Make a guess
    function focusFirstTab (tabsetIndex) {
        tabs[tabsetIndex][0].focus();
    }

    // Make a guess
    function focusLastTab (tabsetIndex) {
        tabs[tabsetIndex][tabs[tabsetIndex].length - 1].focus();
    }

    // Expose public methods
    return {
        init: init,
        activateTab: activateTab
    }

})();

var FileInput = (function() {
    /**
     * Sets up some text we'll need to reuse throughout.
     */
    var defaultText = 'No files selected';

    /**
     * This kicks off our Uploader only if there
     * are any in the document.
     */
    var init = function(context) {
        if (context === undefined) {
            context = document;
        }    

        /**
         * This gets all of the the uploaders in the document
         * so we can work with them in our _bindUiActions function.
         */
        var uploaders = context.querySelectorAll('[data-upload]');

        if(uploaders.length > 0) {
            _bindUiActions(uploaders);
        }
    }

    var _bindUiActions = function (uploaderEls) {
        for(var i = 0; i < uploaderEls.length; i++) {
            // Add the change listener to the file input
            uploaderEls[i].addEventListener('change', function() {

                // Set up
                var uploaderContainer = this;
                var uploaderId = this.getAttribute('data-upload');
                var uploaderInput = this.querySelector('#' + uploaderId);
                var uploadList = this.querySelector('[data-file-preview]');

                // If there were and files added add update the uploadList element
                if (uploaderInput.files.length > 0) {
                    // Clear the placeholder text so we can insert our file names.
                    uploadList.innerHTML = '';

                    // Check if there are multiple or single files.
                    if (uploaderInput.files.length > 1) {
                        uploadList.appendChild(
                            buildMultipleFiles(uploaderInput)
                        );
                    }
                    else {
                        uploadList.appendChild(
                            buildSingleFile(uploaderInput)
                        );
                    }
                }
                else {
                    uploadList.innerHTML = defaultText;
                }
            });
        }
    }

    /**
     * Builds a preview for multiple files
     */
    var buildMultipleFiles = function (htmlFileInput) {
        var fileCount = document.createElement('span');
        fileCount.textContent = htmlFileInput.files.length + ' files selected';
        return fileCount;
    }

    /**
     * Builds a single span with file name to insert into the DOM
     */
    var buildSingleFile = function(htmlFileInput) {
        // Create <span> element to display our file name
        var singleFileItem = document.createElement('span');

        // Add the file name as the text content
        singleFileItem.textContent = htmlFileInput.files[0].name;

        // Returns our built <span> element.
        return singleFileItem;
    }

    // Expose the init function
    return {
        init: init
    }

})();




/* eslint-disable */
(function() {
    /**
     * Kick off all components
     */
    Alert.init();
    Drawer.init();
    Dropdown.init();
    Modal.init();
    Tabs.init();
    FileInput.init();
})();
/* eslint-enable */
